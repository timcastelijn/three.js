<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - timcastelijn - object manipulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
			#ctrl {
				position: absolute;
				top: 0px;
				left: 0px;
				width: 300px;
				color: #000000;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				z-index:0;
			}
			.slider_100
			{
    		width: 100px;
			}
			.slider_125
			{
				width: 125px;
			}
			#ctrl2 {
				position: absolute;
				top: 120px;
				left: 0px;
				color: #000000;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				z-index:0;
			}
			.label-geld{
				font-size: 30px;
			}
			.button {
				color: white;
				font-family: Monospace;
				margin: 0px;
				width: 120px;
				height: 40px;
				background-color: #555555;
				border: none;
			} /* Black */

		</style>
	  <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
	</head>
	<body>
		<div id="ctrl">
			use slider to manipulate selected object:<br/>
			<table>
				<tr>
					<td>front height</td>
					<td><input class = "slider_125" type="range" value="200" min="0" max="250" onInput="mesh.morphTargetInfluences[ 0 ] = (this.value-100)/150; $( 'td.label_front' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); " onchange="mesh.morphTargetInfluences[ 0 ] = (this.value-100)/150; $( 'td.label_front' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); "></td>
					<td class=label_front>200 cm</td>
				<tr>
					<td>rear height</td>
					<td><input class = "slider_125" type="range" value="200" min="0" max="250" onInput="mesh.morphTargetInfluences[ 1 ] = (this.value-100)/150;$( 'td.label_rear' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); " onchange="mesh.morphTargetInfluences[ 1 ] = (this.value-100)/150;$( 'td.label_rear' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); "></td>
					<td class=label_rear>200 cm</td>
				<tr>
					<td>width</td>
					<td><input class = "slider_100" type="range" value="100" min="0" max="200" onInput="mesh.morphTargetInfluences[ 2 ] = (this.value-100)/100; $( 'td.label_width' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); " onchange="mesh.morphTargetInfluences[ 2 ] = (this.value-100)/100; $( 'td.label_width' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); "></td>
					<td class=label_width>100 cm</td>
				<tr>
					<td>depth</td>
					<td><input class = "slider_100" type="range" value="100" min="0" max="200" onInput="mesh.morphTargetInfluences[ 3 ] = (this.value-100)/100;$( 'td.label_depth' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); " onchange="mesh.morphTargetInfluences[ 3 ] = (this.value-100)/100;$( 'td.label_depth' ).text( this.value + ' cm'); var price = calcCosts(); $( 'td.label-geld' ).text( '€' +price); "></td>
					<td class=label_depth>100 cm</td>
			</table>
		</div>
		<div id="ctrl2">
			<table>

					<td><p>&nbsp;</p>
				<tr>
					<td align=right class=label-geld>€1500</td>
			</table>
		</div>



		<script src="../build/three.min.js"></script>

		<script src="js/controls/TrackballControls.js"></script>
		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src="js/Detector.js"></script>

		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>
		<script src="../src/extras/geometries/CubeGeometry.js"></script>
		<script src="../src/materials/LineBasicMaterial.js"></script>
		<script src="../src/materials/LineDashedMaterial.js"></script>


		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, controls, scene, projector, renderer;
			var objects = [], plane, contourLine;
			var mesh, lastKeyframe;
      var mode = 0;
			var grid=[];
			var CAST_SHADOW = false;

			var cont_costs = []

			//basic box dimensions
			var l=0.2, w=0.1, h=0.6;


			var mouse = new THREE.Vector2(),
			offset = new THREE.Vector3(),
			INTERSECTED, DRAGGED, SELECTED;
      var draggables=[];
      var g_line_intersection;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );


				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.5, 100 );
				camera.position.z = 5;
				camera.position.y = -5;

        addSceneLighting();


				//contourLine = new ContourLine();


        var modelLoadedCallback = function( geometry, materials ) {

					mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x606060, shading:THREE.FlatShading, morphTargets: true, vertexColors: THREE.FaceColors } ) );
					// mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0x606060, morphTargets: true, vertexColors: THREE.FaceColors } ) );
					console.log(mesh);
          mesh.traverse( function ( child )
          {
              if ( child instanceof THREE.Mesh )
                  child.material.color.setRGB (1, 1, 1);
                  //objects.push( child );
                  //draggables.push(child);
          });
					mesh.morphTargetInfluences[ 0 ] = 0.66
					mesh.morphTargetInfluences[ 1 ] = 0.66

					mesh.castShadow = CAST_SHADOW;
					mesh.receiveShadow = CAST_SHADOW;


					scene.add( mesh );
				}

				var json_loader = new THREE.JSONLoader( true );
				// use python -m SimpleHTTPServer and
				// http://localhost:8000/examples/tc_webgl_sauna_new.html
				// to bypass cross origin policy

				json_loader.load( "models/animated/sauna/sauna.js", modelLoadedCallback);
			//	json_loader.load( "models/animated/sauna.js", modelLoadedCallback);
				// json_loader.load( "models/animated/window.js", modelLoadedCallback);

				plane = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true, wireframe: true } ) );

        plane.visible = false;
				scene.add( plane );

				snap_plane = new THREE.Mesh( new THREE.PlaneGeometry( 10, 10, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true, wireframe: true } ) );
				scene.add( snap_plane );

				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.sortObjects = false;
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.shadowMapEnabled = true;
				renderer.shadowMapType = THREE.PCFShadowMap;

				container.appendChild( renderer.domElement );

        // apply trackball controls to domElement only

				controls = new THREE.TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				// controls = new THREE.OrbitControls( camera, renderer.domElement );
				// //controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
				// controls.enableDamping = true;
				// controls.dampingFactor = 0.25;
				// controls.enableZoom = true;
				// // camera.up.set( 0, 0, 1 );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '0px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> webgl -  <a href="http://timcastelijn.nl">timcastelijn.nl</a> - sauna manipulator';
				container.appendChild( info );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.right = '0px';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				//

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

      	var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

        // contourLine.updateOnHit(raycaster)

				if ( DRAGGED ) {

					applySelectionColor(DRAGGED)

          // get the intersection with the base plane
					var intersects = raycaster.intersectObjects( grid );
          if (intersects[0]){
						// intersects[ 0 ].object.visible = false;
          	DRAGGED.position.copy( intersects[ 0 ].object.position );
					}else{
						var intersects = raycaster.intersectObject( plane );
						if (intersects[0]){
							DRAGGED.position.copy( intersects[ 0 ].point.sub( offset ) );
						}
					}
          return;


				}else{
				  // get the draggable object
  				var intersects = raycaster.intersectObjects( draggables );

  				if ( intersects.length > 0 ) {

  					if ( INTERSECTED != intersects[ 0 ].object ) {

  						INTERSECTED = intersects[ 0 ].object;

  					}

  					container.style.cursor = 'pointer';

  				} else {

  					INTERSECTED = null;

  					container.style.cursor = 'auto';

  				}


				}

			}

			function calcCosts(){
				price = 0;
				for(i=0; i<4; i++){
						price = price + mesh.morphTargetInfluences[i] * 800;
				}
				return parseInt(price);
			}

      function changeMode(){
        mode = document.getElementById("mySelect").value
        console.log("this" + mode);

        //erase all colour
        for ( var i = 0; i < objects.length; i ++ ) {
			    objects[i].traverse( function ( child )
          {
            if ( child instanceof THREE.Mesh )
              child.visible = (mode == "0");
          });
        }

      }


			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

				var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );




				if ( INTERSECTED ) {

					controls.enabled = false;

          if ( (SELECTED != INTERSECTED) || SELECTED == null){
            SELECTED = INTERSECTED;
          } else {
            SELECTED = null;
          }

          DRAGGED = INTERSECTED;

          var intersects = raycaster.intersectObject( plane );
          if (intersects[0]){

						DRAGGED.position.copy( intersects[0].point );

            container.style.cursor = 'move';
          }


				}


        // if(g_line_intersection){
        //   contourLine.addVertex(g_line_intersection, 2);
        // }

			}

			function onDocumentMouseUp( event ) {

				event.preventDefault();

				controls.enabled = true;

				if ( INTERSECTED ) {


					DRAGGED = null;

				}

        //contourLine.update()

				// clear selection color
				applySelectionColor(DRAGGED)


				container.style.cursor = 'auto';

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				controls.update();

				renderer.render( scene, camera );

			}

      function addSceneLighting(){

			  scene.add( new THREE.AmbientLight( 0x505050 ) );

				var intensity = 0.5;
				light = new THREE.SpotLight( 0xffffff, intensity, 0, Math.PI / 2, 1 );
				light.position.set( 5, -15, 10 );
				light.target.position.set( 0, 0, 0 );
			  light.castShadow = CAST_SHADOW;

				light.shadowCameraNear = 1;
				light.shadowCameraFar = 25;
			  light.shadowCameraFov = 50;

		    light.shadowBias = -0.00022;
			  light.shadowDarkness = 0.2;

			  light.shadowMapWidth = 2048;
			  light.shadowMapHeight = 2048;

			  scene.add( light );
      }

			function polyLine( center, len, width ) {


				var geometry = new THREE.Geometry();

				vec = [

					new THREE.Vector3( center.x - len/2, center.y - width / 2, center.z),
					new THREE.Vector3( center.x - len/2, center.y + width / 2, center.z),
					new THREE.Vector3( center.x + len/2, center.y + width / 2, center.z),
					new THREE.Vector3( center.x + len/2, center.y - width / 2, center.z),
					new THREE.Vector3( center.x - len/2, center.y - width / 2, center.z),

				]

        for ( var i = 0; i < vec.length; i ++ ) {

          geometry.vertices[ i ] = vec[i];

        }

				return geometry;

			}

      function applySelectionColor(SELECTED){

        //erase all colour
        for ( var i = 0; i < draggables.length; i ++ ) {
			    draggables[i].traverse( function ( child )
          {
            if ( child instanceof THREE.Mesh )
              child.material.color.setHex ("0x333");
          });
        }

        // apply color to selection if it exists
        if (SELECTED){
          SELECTED.material.color.setHex( "0xff0000" );
        }

      }



			function addBox(){
				var geometry = new THREE.CubeGeometry( l, w, h );
				var material = new THREE.MeshLambertMaterial( { color: 0x333, wireframe: false, vertexColors: THREE.FaceColors  } );
				var cube_mesh = new THREE.Mesh( geometry, material );

				// event.preventDefault();

				// mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				// mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				//

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

      	var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				cube_mesh.position.y = 0
				cube_mesh.position.x = 3

				// cube_mesh.visible = false

				cube_mesh.castShadow = CAST_SHADOW;
				cube_mesh.receiveShadow = CAST_SHADOW;

				draggables.push(cube_mesh);

				scene.add( cube_mesh );

				INTERSECTED = cube_mesh;
				DRAGGED = cube_mesh;

				var intersects = raycaster.intersectObject( plane );
				if (intersects[0]){
					DRAGGED.position.copy( intersects[ 0 ].point.sub( offset ) );
				}
			}

		</script>

	</body>
</html>
